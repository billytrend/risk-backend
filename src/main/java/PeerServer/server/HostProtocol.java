package PeerServer.server;import GameBuilders.RiskMapGameBuilder;import GameEngine.GameEngine;import GameState.Player;import GameState.State;import GeneralUtils.Jsonify;import PeerServer.protocol.general.acknowledgement;import PeerServer.protocol.general.leave_game;import PeerServer.protocol.general.timeout;import PeerServer.protocol.setup.*;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;import java.util.*;import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue;import static com.esotericsoftware.minlog.Log.debug;/** * An instance of this class represents a game that * is currently being played over the network. *  */public class HostProtocol extends AbstractProtocol  {	private int maxNoOfPlayers = 6;		//min is 3		private int minNoOfPlayers = 2;	private int waitTimeInSeconds = 3; // host waits 180 seconds for remaining players to connect	// mappings of features / versions to the count of how many clients support these	private HashMap<String, Integer> supportedFeatures = new HashMap<String, Integer>();	private HashMap<Integer, Integer> supportedVersions = new HashMap<Integer, Integer>();		// maps players IDs with a connection associated with them (null for local)	private HashMap<Integer, PeerConnection> connectionMapping = new HashMap<Integer, PeerConnection>();	private BlockingQueue<String> commandQueue = new LinkedBlockingQueue<String>();	private BlockingQueue<String> acknowledgementsQueue = new LinkedBlockingQueue<String>();		// connection which is currently served	private PeerConnection currentConnection;	private Set<PeerConnection> acknowledgements = new HashSet<PeerConnection>(); // IDs	private Socket newSocket;	private ServerSocket serverSocket;    public HostProtocol(State state) {        this.state = state;    }	@Override	protected void takeSetupAction() {		//Log.DEBUG = true;		ArrayList<String> allCommands;		// check if timer didn't interrupt		if(Thread.interrupted()){			synchronized(currentTask){				try {					currentTask.wait();				} catch (InterruptedException e) {					// TODO Auto-generated catch block					e.printStackTrace();				}			}					}		switch(protocolState){		case JOIN_GAME:			debug("\nJOIN_GAME");			// accept a new client and handle their request			try {				newSocket = serverSocket.accept();				newSocket.setSoTimeout(1000);				DataInputStream fromClient = new DataInputStream(newSocket.getInputStream());								// handle the command and either accept and create player or send them reject msg				handleJoinGameCommand(fromClient.readUTF());			} catch (IOException e) {}						// no need to transfer to the other state - this will happen 			// automatically once we receive enough players and the timeout has passed						break;				case PING:			debug("\n PING");			sendPing();  // the game will be transfered to the next state							// after ack timeout has passed			break;		case READY:			debug("\n READY");			sendReady();      // state will be changed after all ack are handled						break;		case INIT_GAME:			debug("\n INIT_GAME");			sendInitializeGame();			//sendLeaveGame(200, "temporary leave");			protocolState = ProtocolState.SETUP_GAME;			break;		default:			break;		}	}// =====================================================================// HANDLING VARIOUS COMMANDS// =====================================================================// ************************// JOINGING GAME// ************************		/**	 * Used when the server receives request to join the game	 * It handles everything - sends accept command or reject command	 * and adds player if they are accepted. I also sends players_joined	 * command to the accepted player	 * 	 * @param command	 * @return	 */	protected void handleJoinGameCommand(String command) {			System.out.println("\nGOT: " + command + "\n");		//create JSON object of command		join_game join_game = (join_game) Jsonify.getJsonStringAsObject(command, join_game.class);		if(join_game == null){			errorMessage = ("Wrong request");			sendRejectJoin(); // reject player		}				// game will be accepted so update versions and features counts		update(join_game.payload.supported_features, supportedFeatures);		update(join_game.payload.supported_versions, supportedVersions);		String newName = join_game.payload.name;		String newKey =  join_game.payload.public_key;				// accpet a player		sendAcceptJoin(newName, newKey);		sendPlayersJoined(newName, newKey); // send them the information about joined players;	}	/**	 * Sent to the player if they are rejected	 */	protected void sendRejectJoin() {		//create json string 		reject_join_game reject_join_game = new reject_join_game(errorMessage);				String rj = Jsonify.getObjectAsJsonString(reject_join_game);		// dont create peer connection for this client, they are rejected		DataOutputStream out;		try {			out = new DataOutputStream(newSocket.getOutputStream());			//send rejection 			out.writeUTF(rj);		} catch (IOException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}		System.out.println("\nSEND: " + rj);	}	/**	 * Sent to the player if they are accepted - the method also creates a new	 * player with the given name and a key	 * 	 * @param name	 * @param key	 */	protected void sendAcceptJoin(String name, String key) {				// new id generated		int id = startingPlayers.size();		// new connection is created for a new accepted player		PeerConnection newConnection = new PeerConnection(newSocket, id);		connectionMapping.put(id, newConnection);		currentConnection = newConnection;		Player newOne = createNewPlayer(name, id, false);		newOne.setPublicKey(key);		//sending response - about being accepted		accept_join_game accept_join_game =				new accept_join_game(id, ack_timeout, move_timeout);				sendToCurrentConnection(Jsonify.getObjectAsJsonString(accept_join_game));	}			/**	 * Information about all players in the game sent to the newly joined player	 * and to other players to notify them about the newly joined player	 * 	 * @param newName	 * @param newKey	 */	protected void sendPlayersJoined(String newName, String newKey){		players_joined players_joined = new players_joined(startingPlayers);		sendToCurrentConnection(Jsonify.getObjectAsJsonString(players_joined));		// sending only new player to the rest		int id = currentConnection.getId();		players_joined toRest = new players_joined(new String[]{Integer.toString(id), newName, newKey});		sendCommand(Jsonify.getObjectAsJsonString(toRest), id, false); // send to almost all and 																		// don't acknowledge				// if we already got enough players start the timer 		// it will interrupt and change out state to PING after the specified time		if(startingPlayers.size() == minNoOfPlayers){			currentTask = new ChangeState(ProtocolState.PING); 			timer.schedule(currentTask, waitTimeInSeconds * 1000);		}	}	// **********************************// PINGING AND PRE-GAME PREPARATION// **********************************		/**	 * Send a ping command to everyone and receive their pings.	 * If someone does not respond with their pings, remove them.	 * If there is not enough players left, finish the game.	 */	protected void sendPing(){		// add all players to the state - will be deleted later if needed		state.setPlayers(startingPlayers);        RiskMapGameBuilder.colourPlayers(startingPlayers);		// create and send a ping to all clients		ping ping = new ping(startingPlayers.size(), 0);		String p = Jsonify.getObjectAsJsonString(ping);				nextStateAfterAck = ProtocolState.READY;		sendCommand(p, null, true); // send the command to all and expect pings (acknowledgements)	}			/** 	 * Send ready command to everyone and receive their acknowledgements.	 * 	 */	protected void sendReady(){		//send ready command to all connected clients ACK required		ready ready = new ready(null, myID, ack_id);		ack_id++;				// clear all previous acknowledgements		acknowledgements.clear();				nextStateAfterAck = ProtocolState.INIT_GAME;		sendCommand(Jsonify.getObjectAsJsonString(ready), null, true); // send to all																		// and expect acknowledgements	}		/**	 * Send initialise game to everyone. No acknowledgements required.	 */	protected void sendInitializeGame(){		// finding the highest version supported by all		int version = findHighestVersionSupportedByAll(supportedVersions);		// get features that are supported by all		ArrayList<String> features = findFeaturesSupportedByAll(supportedFeatures);		String[] feat = new String[features.size()];		features.toArray(feat);		engine = new GameEngine(state, networkArbitration);				initialise_game init_game = new initialise_game(version, feat);		sendCommand(Jsonify.getObjectAsJsonString(init_game), null, false); // send to all, no acks	}		/**	 * Send leave game to everyone. Finishes the game.	 * @return	 */	protected void sendLeaveGame(int leaveCode, String leaveReason) {		leave_game leave = new leave_game(leaveCode, leaveReason, false, 0);		sendCommand(Jsonify.getObjectAsJsonString(leave), null, false);		// wait a bit for everyone to receive hosts leaving message		try {			Thread.sleep(5000);		} catch (InterruptedException e) {			e.printStackTrace();		}				protocolState = null;	}			/**	 * Handles a leave game command received from someone. It removes the player	 * from the game.	 * @param command	 */	protected void handleLeaveGame(String command){		// if command is not empty sb sent a leave_command		leave_game leave = (leave_game) Jsonify.getJsonStringAsObject(command, leave_game.class);		//TODO: print a reason?		int responseCode = leave.payload.response;		String message = leave.payload.message;		int id = leave.player_id;		sendCommand(command, id, false); // send to all except the one leaving											// no acknowledgements		removePlayer(currentConnection);				if(numOfPlayers < minNoOfPlayers){ // leave yourself if there is not enough players			sendLeaveGame(200, "Not enough players");              // TODO: replace the guy with AI !		}	}		// =====================================================================// HELPER FUNCTIONS// =====================================================================	/**	 * Removes the given connection from the list of supported connections	 * and a player associated with it from the game state	 * @param connection	 */	protected void removePlayer(PeerConnection connection){		int ID = -1;		for(int id : connectionMapping.keySet()){			if(connectionMapping.get(id) == connection)				ID = id;		}		if(ID != -1){			connectionMapping.remove(ID);			// remove that player from the game state			removePlayer(ID);		}	}	/**	 * Returns an array of features supported by all players	 * @param map	 * @return	 */	private ArrayList<String> findFeaturesSupportedByAll(			HashMap<String, Integer> map) {		ArrayList<String> features = new ArrayList<String>();		for(String a : map.keySet()){			if(map.get(a) == connectionMapping.size())				features.add(a);		}			return features;	}	/**	 * It removes the highest version supported by all players	 * @param map	 * @return	 */	private int findHighestVersionSupportedByAll(HashMap<Integer, Integer> map){		int supported = 1;		Iterator<Integer> it = map.keySet().iterator();		while(it.hasNext()){			Integer current = it.next();			if(map.get(current) == connectionMapping.size())				supported = current;		}		return supported;	}	/**	 * Updates a given mapping based on the input array.	 * Increases count of features / versions specified in the array.	 * 	 * @param input	 * @param toUpdate	 */	private void update(Object[] input,	HashMap toUpdate) {		Arrays.sort(input);		Integer count;		for(Object a : input){			if(toUpdate.containsKey(a)){				count = (Integer) toUpdate.get(a);				toUpdate.put(a, count + 1);			}			else{				toUpdate.put(a, 1);			}		}	}// =====================================================================// SENDING AND RECEIVING COMMANDS AND ACKNOWLEDGEMENTS// =====================================================================		/**	 * Receives acknowledgements (either ping or acknowledgement)	 * it keeps receiving these until the timeout passes.	 * 	 * @param command	 * @return	 */	protected void acknowledge(String command) {		if(command.contains("ping")){			ping ping = (ping) Jsonify.getJsonStringAsObject(command, ping.class);			if(ping == null){				sendLeaveGame(200, "Wrong command: expected ping");			}			sendCommand(command, ping.player_id, false);		}		else if(command.contains("leave")){ // TODO: think about this.			handleLeaveGame(command); 			return;		}		else if(command.contains("acknowledgement")){			acknowledgement ack = (acknowledgement) Jsonify.getJsonStringAsObject(command, acknowledgement.class);			if(ack == null){				sendLeaveGame(200, "Wrong command: expected acknowledge");			}			if((ack.payload != ack_id - 1) && (ack.payload != their_ack_id)){				System.out.println("Wrong acknoledgement - but we ignore it");			}		}		else{			// it wasnt an acknowledgement by may be important later			// add this to the command queue			System.out.println("got something while acknowledging: " + command + "\n");			if(command != "")				commandQueue.add(command);			return;		}				acknowledgements.add(currentConnection);	}		@Override	/**	 * Is sends commands to either all players or all players except	 * the one with the given exceptId. Depending on whether the acknowledge	 * boolean is set to true or false the method also handles all acknowledgements	 * to the command that was just sent. 	 * 	 * @param command	 * @param exceptId	 * @param acknowledge	 */	protected void sendCommand(String command, Integer exceptId, boolean acknowledge) {		if(exceptId != null)			sendToAllExcept(command, exceptId);		else			sendToAll(command);				if(!acknowledge)			return;				currentTask = new ChangeState(nextStateAfterAck);		timer.schedule(currentTask, ack_timeout * 1000);		while(true){			if(Thread.interrupted()){				synchronized(currentTask){					try {						currentTask.wait();					} catch (Exception e) {e.printStackTrace();}				}				break;			}									// it will keep receiving commands by looping			// through all connections 			String received = receiveCommand();			if(received != ""){				acknowledge(received); // receive acks until interrupted			}			if(acknowledgements.size() == numOfPlayers -1){				protocolState = nextStateAfterAck;				timerSet = false;				currentTask.cancel();				return;			}		}					if(command.contains("ping"))			handlePingTimeouts();		else			handleAckTimeouts(exceptId); 					if(!command.contains("timeout")){ // don't do it for timeouts since it will 												// be sent later either way			if(numOfPlayers < minNoOfPlayers){ 				sendLeaveGame(200, "Not enough players");			}		}	}		/**	 * Checks whether all users responded with an acknowledgement. 	 * If some haven't they are removed and a timeout command is sent to 	 * all other players	 * 	 * @param exceptId	 */	private void handleAckTimeouts(Integer exceptId) {		for(PeerConnection c : connectionMapping.values()){			if(!acknowledgements.contains(c)){				if((exceptId == null) || (connectionMapping.get(exceptId) != c)){					// removing players that have not sent acknowledgement					// message about timeout needs to be sent to all players					timeout timeout = new timeout(c.getId(), myID, ack_id);					ack_id++;					removePlayer(c);						sendCommand(Jsonify.getObjectAsJsonString(timeout), null, true); // timeout needs to be acknowledged				}			}		}	}		private void handlePingTimeouts() {		for(PeerConnection c : connectionMapping.values()){			if(!acknowledgements.contains(c)){				// removing players that have not sent acknowledgement				// message about timeout needs to be sent to all players				removePlayer(c);			}		}	}	/**	 * Sends a given command to all supported connections (all clients)	 * @param command	 */	private void sendToAll(String command){		System.out.println("SEND TO ALL: " + command + "\n");		for (PeerConnection c : connectionMapping.values()) {			c.sendCommand(command);		}	}	/**	 * Sends the command to all connections except the one wiht the specified id	 * @param command	 * @param playerId	 */	private void sendToAllExcept(String command, int playerId) {		PeerConnection con = connectionMapping.get(playerId);		System.out.println("SEND TO ALMOST ALL: " + command + "\n");		for (PeerConnection c : connectionMapping.values()) {			if(c != con){				System.out.println("sending.. should never be here");				c.sendCommand(command);			}		}	}		/**	 * Sends the command to the connection that is currently handled	 * @param command	 */	private void sendToCurrentConnection(String command){		System.out.println("SEND: " + command + "\n");		currentConnection.sendCommand(command);	}			int previouslyHandledId = 0;	@Override	protected String receiveCommand() {		if(connectionMapping.size() == 0)			return "";			String command = "";		if(commandQueue.size() != 0){			System.out.println("queue not empty!");			command = commandQueue.poll();			previouslyHandledId = getPlayerid(command);			System.out.println("got id: " + previouslyHandledId);			currentConnection = connectionMapping.get(previouslyHandledId);		}		else{			int idToHandle = (((previouslyHandledId + 1) % connectionMapping.size())) + 1;			PeerConnection con = connectionMapping.get(idToHandle);			command = con.receiveCommand();			currentConnection = con;			previouslyHandledId = idToHandle;		}					if(command != "")			System.out.println("GOT FROM " + previouslyHandledId + ": " + command + "\n");		return command;	}		private int getPlayerid(String command) {		String[] parts = command.split(",");		for(int i = 0; i < parts.length; i++){			if(parts[i].contains("player_id")){				String parts2[] = parts[i].split(":");				return (parts2[1].charAt(0) - 48);			}		}		return -1;	}// =====================================================================// RUNNING THE HOST // =====================================================================	public void run(){		myName = getRandomName();		createNewPlayer(myName, 0, true);		// creating our local player		try {			serverSocket = new ServerSocket(4444);			serverSocket.setSoTimeout(6000); // socket waits for 2 seconds -- needed for checking interrupts		} catch (IOException e) {			e.printStackTrace();		}		super.run();		timer.cancel();		// closing all sockets		for(PeerConnection con : connectionMapping.values()){			con.close();		}		try {			serverSocket.close();		} catch (IOException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}	}		public static void main(String[] args) {		HostProtocol protocol = new HostProtocol(new State());		protocol.run();	}	@Override	protected void acknowledge(int ack) {		// TODO Auto-generated method stub			}	}